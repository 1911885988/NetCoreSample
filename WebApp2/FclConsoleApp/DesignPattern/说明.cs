using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FclConsoleApp.DesignPattern
{
  /*  
 1 创建型模式
 创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。
 第一，它们都将系统使用哪些具体类的信息封装起来；
 第二，它们隐藏了这些类的实例是如何被创建和组织的。

 创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。
单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。
抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。
工厂方法：创建单个对象，在Abstract Factory有使用到。
原型模式：通过拷贝原型来创建新的对象。
工厂方法，抽象工厂, 建造者都需要一个额外的工厂类来负责实例化“一个对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。

*/

    /*
     结构型模式包括：适配器模式(DataAdapter)、桥接模式(BLL引用Dao)、装饰者模式（手机贴膜+外壳）、组合模式(树)、外观模式（封装相关关联子对象，并返回结果）、享元模式（只创建一个实例）和代理模式（Web服务引用），
     行为型模式的第一个模式：模板方法模式
     */

    /*
    1 抽象工厂模式解决了“系列产品”的需求变化，而建造者模式解决的是 “产品部分” 的需要变化
     
     */


    //1.单例模式　
    //2.工厂方法模式　
    //3.抽象工厂模式　 解决了“系列产品”的需求变化
    //4.建造者模式     解决的是 “产品部分” 的需要变化
    //5模版方法模式

    //6.代理模式　
    //7.原型模式　
    //8.中介者模式
    //9.命令模式　10.责任链模式　11.装饰模式　12.策略模式　13.适配器模式　14.迭代器模式　15.组合模式　16.观察者模式　
    //17.门面模式　18.备忘录模式　19.访问者模式　20.状态模式　21.解释器模式　22.享元模式　23.桥梁模式



    //1.  单一职责原则（Single ResponsibilityPrinciple）
    //2.  里氏替换原则（Liskov SubstitutionPrinciple）
    //3.  依赖倒置原则（Dependence InversionPrinciple）
    //4.  接口隔离原则（Interface SegregationPrinciple）
    //5.  迪米特法则（Law OfDemeter）
    //6.  开闭原则（Open ClosePrinciple）


    /*
     传吧
     1 SQL Oracle类型等导出数据时，可以用建造者模式构建

     */

}
